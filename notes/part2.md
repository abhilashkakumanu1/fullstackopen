# Communicating with server

## Rendering a collection, modules

The list items, i.e. the elements generated by the map method, must each have a unique key value: an attribute called key. React uses the key attributes of objects in an array to determine how to update the view generated by a component when the component is re-rendered. 

**Anti-pattern: array indexes as keys**: Passing index of an element as the key is not recommended and can cause undesired problems even if it seems to be working just fine. 

In smaller applications, components are usually placed in a directory called components, which is in turn are placed within the src directory. The convention is to name the file after the component.

## Forms

**Controlled components**: In HTML, form elements such as `<input>, <textarea>, and <select>` typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with setState(). We can combine the two by making the React state be the “single source of truth”. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a “controlled component”.

We can directly view how the state changes from the React Devtools tab.

## Getting data from server

The React code fetches the notes from the server and renders them to the screen. Whenever a new note is added to the application the React code also sends it to the server to make the new note persist in "memory".

Currently, JavaScript engines are single-threaded, which means that they cannot execute code in parallel. As a result, it is a requirement in practice to use a non-blocking model for executing IO operations. Otherwise, the browser would "freeze" during, for instance, the fetching of data from a server. Also for the browser to remain responsive, i.e. to be able to continuously react to user operations with sufficient speed, the code logic needs to be such that no single computation can take too long.

**npm-commands should always be run in the project root directory**, which is where the package.json file can be found.

If, and when, we want to access the result of the operation represented by the promise, we must register an event handler to the promise. This is achieved using the method **then**. 

**Effect-hooks**: The Effect Hook lets you perform side effects in function components. Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects.

The second parameter of `useEffect` is used to specify how often the effect is run. If the second parameter is an empty array `[]`, then the effect is only run along with the first render of the component.

## Altering data in server

### REST

In REST terminology, we refer to individual data objects, such as the notes in our application, as resources. Every resource has a unique address associated with it - its URL. According to a general convention used by json-server, we would be able to locate an individual note at the resource URL notes/3, where 3 is the id of the resource. The notes url, on the other hand, would point to a resource collection containing all the notes.

Resources are fetched from the server with HTTP GET requests. For instance, an HTTP GET request to the URL notes/3 will return the note that has the id number 3. An HTTP GET request to the notes URL would return a list of all notes.

Creating a new resource for storing a note is done by making an HTTP POST request to the notes URL according to the REST convention that the json-server adheres to. The data for the new note resource is sent in the body of the request.

json-server requires all data to be sent in JSON format. What this means in practice is that the data must be a correctly formatted string, and that the request must contain the Content-Type request header with the value application/json. If the data we sent in the POST request was a JavaScript object, axios automatically sets the appropriate application/json value for the Content-Type header.

**Not all axios requests should be kept in `useEffect` hook**. We can make a POST request on button click.

PUT replaces the entire note where as PATCH only change some of the note's properties. 

In the spirit of the *single responsibility principle*, it is wise to extract this communication into its own module.

### Adding styles to React app

CSS rules comprise of selectors and declarations. The selector defines which elements the rule should be applied to.

Using element types for defining CSS rules is slightly problematic. If our application contained other tags of same type, the same style rule would also be applied to them.

**Inline styles**: Every CSS property is defined as a separate property of the JavaScript object. Numeric values for pixels can be simply defined as integers. One of the major differences compared to regular CSS, is that hyphenated (kebab case) CSS properties are written in camelCase.